package com.github.chronos2011.fretter;

import com.github.chronos2011.fretter.application.Configuration;
import com.github.chronos2011.fretter.domain.solver.*;
import com.github.chronos2011.fretter.options.ApplicationOptions;
import com.github.chronos2011.fretter.options.ApplicationOptions.Operation;
import com.github.chronos2011.fretter.options.OptionsExtractor;
import com.github.chronos2011.fretter.presentation.ConsoleSolutionRenderer;
import com.github.chronos2011.fretter.presentation.SolutionRenderer;

/**
 * Class Fretter implements the top-level application logic:
 * <ul>
 * <li>command-line arguments are sent to an {@link OptionsExtractor} for generation of {@link ApplicationOptions};</li>
 * <li>{@link ApplicationOptions} select the mode of {@link Operation} and the corresponding {@link Solver};</li>
 * <li>a {@link SolutionRenderer} presents the {@link Solution} generated by the {@link Solver}.</li>
 * </ul>
 */
public class Fretter {
    /**
     * Implements the program entry point.
     *
     * @param arguments the command-line arguments received
     */
    public static void main(String[] arguments) {
        printIdentification();
        OptionsExtractor optionsExtractor = new OptionsExtractor();
        ApplicationOptions applicationOptions = optionsExtractor.extract(arguments);
        if (applicationOptions == null || applicationOptions.operation == null)
            System.exit(1);
        new Fretter(applicationOptions).run();
    }

    /**
     * Prints the identification of the application.
     */
    public static void printIdentification() {
        String name = Configuration.applicationName;
        String version = Configuration.applicationVersion;
        String description = Configuration.applicationDescription;
        System.out.println();
        System.out.println(name + " v" + version + " - " + description);
        System.out.println();
    }

    private final ApplicationOptions applicationOptions;

    /**
     * Creates a new Fretter.
     *
     * @param applicationOptions the {@link ApplicationOptions} to be used
     */
    public Fretter(ApplicationOptions applicationOptions) {
        this.applicationOptions = applicationOptions;
    }

    /**
     * Runs the application main logic, using a {@link Solver} to generate a {@link Solution} and using a
     * {@link SolutionRenderer} to render the {@link Solution}.
     */
    public void run() {
        Solver solver;
        switch (applicationOptions.operation) {
            case BOARD:
                solver = new BoardSolver(applicationOptions);
                break;
            case SCALE:
                solver = new ScaleSolver(applicationOptions);
                break;
            case ARPEGGIO:
                solver = new ArpeggioSolver(applicationOptions);
                break;
            case CHORD:
                solver = new ChordSolver(applicationOptions);
                break;
            default:
                return;
        }
        Solution solution = solver.solve();
        SolutionRenderer renderer = new ConsoleSolutionRenderer();
        System.out.print(renderer.render(applicationOptions, solution));
    }
}